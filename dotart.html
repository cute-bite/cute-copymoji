<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Dot Art Generator - Cute CopyMoji | ASCII & Braille Style Text Art</title>
<meta name="description" content="Create and copy dot art (ASCII, Braille-style text art) with Cute CopyMoji. Perfect for social media captions, profiles, and messages. One-click copy & paste.">

  <link rel="stylesheet" href="./index.css" />

  <style>
  /* ====== 필터 바 ====== */

    /* === TIGHT DOT/ASCII OVERRIDES === */
    @media (max-width: 768px){
      .dot-card pre{ font-size: clamp(8px, 2.4vw, 10px); line-height: calc(1em + 1px); }
    }
    

  /* ====== ASCII 전용 스타일 ====== */
  /*=== ASCII 전용: CJK 모노 우선 + 반각 고정 ===*/
.ascii-pre{
  white-space: pre;
  letter-spacing: 0;
  overflow: auto;
  tab-size: 2;
  font-variant-east-asian: normal;   /* ← 반각 강제 해제 */
  font-family:
    "MS Gothic","MeiryoKe_Console","Noto Sans Mono CJK JP",
    "Noto Sans Mono","Noto Mono",
    ui-monospace,SFMono-Regular,Menlo,Consolas,"Liberation Mono","Courier New",
    monospace;
  text-align: left;                   /* ← 줄은 좌측 정렬(형상 보존) */
  display: block;                     /* ← 블록은 컨테이너가 가운데 */
  margin: 0;
}

  
  .ascii-card{ content-visibility:auto; contain-intrinsic-size: 100px 100px; }

  .filters{ 
  display:flex; 
  flex-wrap:wrap; 
  align-items:center; 
  justify-content:center; 
  gap:8px; 
  margin-bottom: 0px;  /* 하단 여백 추가 */
  padding: 10px 0;      /* 상하 내부 여백 추가 */
}

  .filters .chip{ margin:0; }

  /* ====== 상단 툴바/검색은 숨김(필요시 살려도 됨) ====== */
  .toolbar{ display:none; }

   /* ===== Dot Art 레이아웃 ====== */
  .section{ margin-top:2px; }
  .section h3{ margin:0 0 8px; font-size:16px; font-weight:700; }

  /* 하단 Dot Art 섹션 여백 추가 */
  #dotSection{ 
  margin-top: 1px;  /* 상단 여백 추가 */
  padding-top: 1px; /* 내부 상단 여백 */
  }

  /* Dot Art 카드 그리드 여백 조정 */
  #grid{ display:grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap:8px; justify-content:center; align-items:start; margin-top:10px; }
  #asciiGrid{ display:grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap:8px; justify-content:center; align-items:start; margin-top:10px; }

  /* 빈 상태 여백 조정 */
  #empty{ 
  display: none; 
  text-align:center; 
  color:var(--muted); 
  margin: 24px 0;  /* 기존 16px에서 24px로 증가 */
  }
  /* Converter 컨테이너 */
  .convert-wrap{ display:grid; gap:14px; }
  .convert-row{ display:flex; gap:14px; align-items:flex-start; flex-wrap:wrap; }
  .convert-col{ flex:1 1 380px; min-width:280px; background:var(--card); border:1px solid var(--border); border-radius:14px; box-shadow:var(--shadow); padding:12px; height:500px; display:flex; flex-direction:column; }
  .upload{ display:grid; gap:12px; flex:1; }
  .file-upload{ position:relative; border:2px dashed var(--accent); border-radius:16px; padding:20px; background:linear-gradient(135deg, var(--chip) 0%, var(--bg) 100%); text-align:center; transition:all .3s ease; cursor:pointer; }
  .file-upload:hover{ border-color:var(--accent-2); background:linear-gradient(135deg, var(--accent-2) 0%, var(--chip) 100%); transform:translateY(-2px); }
  .file-upload input[type="file"]{ position:absolute; inset:0; width:100%; height:100%; opacity:0; cursor:pointer; }
  .upload-hint{ color:var(--accent); font-weight:600; font-size:14px; margin-top:8px; display:flex; flex-direction:column; align-items:center; gap:6px; }
  .upload-hint .icon{ font-size:28px; line-height:1; }
  .upload-hint .label{ font-size:12px; color:var(--muted); }
  .ctrl-box{ background:var(--chip); border:1px solid var(--border); border-radius:12px; padding:16px; margin:8px 0 10px; }
  .ctrls{ display:flex; flex-direction:column; gap:16px; }
  .ctrl{ display:flex; flex-direction:column; gap:10px; }
  .ctrl .label{ font-weight:600; color:var(--text); font-size:14px; }
  .ctrl input[type="range"]{ width:100%; height:20px; accent-color:var(--accent); }
  .ctrl input[type="checkbox"]{ accent-color:var(--accent); transform:scale(1.2); margin-left:6px; }

  .preview{ display:flex; gap:10px; flex-wrap:wrap; min-height:180px; align-items:center; justify-content:center; flex-direction:column; border:1px solid var(--border); border-radius:12px; background:var(--card); padding:16px; }
  .preview.has-image .hint{ display:none; }
  .preview-img{ width:200px; height:150px; object-fit:contain; border:1px solid var(--border); border-radius:10px; background:var(--bg); }
  .result{
    width:100%; max-height:400px; border:1px solid var(--accent-2); border-radius:12px; background:var(--card);
    color:var(--text); padding:8px 16px; font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
    white-space:pre; overflow:auto; text-align:center; flex:1; resize:none; font-size:9px; line-height:10px;
    display:flex; align-items:center; justify-content:center;
  }

  /* Dot Art 카드 그리드 */
  #grid{ display:grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap:8px; justify-content:center; align-items:start; margin-top:10px; }
  #asciiGrid{ display:grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap:8px; justify-content:center; align-items:start; margin-top:10px; }
  .dot-card{ background:var(--card); border:1px solid var(--border); border-radius:14px; box-shadow:var(--shadow); padding:12px; cursor:pointer; transition:background .15s ease, border-color .15s ease; position:relative;  display:flex; justify-content:center; }
  .dot-card:hover{ background:var(--chip); border-color:var(--border); }
  .dot-card pre{margin:0;white-space:pre;word-break:normal;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:9px;line-height:10px;letter-spacing:0;text-align:center;}
  .dot-meta{ position:absolute; top:8px; right:8px; display:flex; gap:6px; }
  .fav-btn{ border-radius:10px; padding:4px 6px; border:1px solid var(--border); background:var(--card); cursor:pointer; }
  .fav-btn[aria-pressed="true"]{ border-color:var(--accent); background:var(--chip); }

  /* 빈 상태 */
  #empty{ display:none; text-align:center; color:var(--muted); margin:16px 0; }

  /* Toast (하단 고정 — 기존 그대로) */
  #toast{ position:fixed; left:50%; transform:translateX(-50%); bottom:24px; background:var(--card); border:1px solid var(--border); padding:8px 12px; border-radius:10px; box-shadow:var(--shadow); opacity:0; transition:opacity .2s; z-index:9999; }
  #toast.show{ opacity:1; }

  @media (max-width:768px){
    .convert-row{ flex-direction:column; }
    .convert-col{ height:auto; min-height:300px; }
  }



  /* ===== Dot Art Converter: responsive fix overrides ===== */

/* 태블릿: 두 칼럼 유지하면서 여백/높이 완화 */
@media (max-width: 1024px){
  .convert-row{ gap:12px; }
  .convert-col{ height:auto; min-height:340px; }
  .preview-img{ max-width:100%; height:auto; max-height:220px; }
  .result{ font-size: clamp(9px, 1.2vw, 12px); line-height: calc(1em + 1px); }
}

/* 모바일: 단일 칼럼으로 안전하게 스택 */
@media (max-width: 768px){
  .convert-row{ flex-direction:column; gap:12px; }
  .convert-col{
    flex: 1 1 auto; 
    min-width: 100%;   /* ← 칼럼 최소폭 강제 해제 */
    height: auto; 
    min-height: 300px; /* 내용이 눌리지 않게 최소 높이만 */
  }
  .upload, .preview{ width:100%; }
  .preview{ align-items:center; justify-content:center; }
  .preview-img{
    width: 100%;        /* ← 고정폭 제거 */
    height: auto;
    max-height: 200px;  /* 화면을 넘지 않도록 상한 */
    object-fit: contain;
  }
  .result{
    width: 100%;
    min-height: 220px;
    /* 도트 정렬은 유지하면서 작아진 화면에 적응 */
    font-size: clamp(8px, 2.4vw, 12px);
    line-height: calc(1em + 1px);
    overflow: auto;     /* 가로 스크롤 필요 시 안전 */
    text-align: left;   /* 중앙정렬에서 줄바꿈 오해 방지 */
    justify-content: flex-start; /* flex 중앙 정렬로 인한 깨짐 방지 */
    align-items: flex-start;
  }
}

/* 초소형 기기: 내부 패딩/갭 더 줄이기 */
@media (max-width: 420px){
  .convert-col{ padding:10px; }
  .ctrl-box{ padding:12px; margin:6px 0 8px; }
  .ctrls{ gap:12px; }
}


/* 모바일 이하: 결과 영역 가운데 정렬 보정 */
@media (max-width: 768px){
  .result {
    justify-content: center;   /* 가로 가운데 정렬 */
    align-items: flex-start;    /* 세로는 위쪽부터 */
    text-align: center;         /* 텍스트 줄바꿈도 가운데 */
  }
}


  
  /* === UNIFORM CARD FRAME (Dot/ASCII) 카드 프레임 크기 수정=== */
  :root{
    --dot-card-h: 220px;   /* frame height (adjust if needed) */
    --dot-card-pad: 12px;  /* same as .dot-card padding */
  }
  .dot-card{
    height: var(--dot-card-h);
    display:flex; align-items:center; justify-content:center; /* center content */
  }
  .dot-card pre{
    max-height: calc(var(--dot-card-h) - 2*var(--dot-card-pad));
    overflow: auto;                 /* long arts scroll inside */
    margin: 0 auto;                 /* keep centered */
    text-align: center;             /* horizontal center */
  }
  /* Make ASCII/Dot grids consistent */
  #grid, #asciiGrid{ grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap:8px; }

  /* === ASCII 전용 오버라이드 (Dot에는 영향 없음) === */
#asciiSection { --dot-card-h: 120px; }                 /* 세로만 ↓ */
#asciiGrid     { grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); }  /* 가로만 ↑ */
#asciiSection .dot-card pre { font-size: 8px; line-height: 9px; }  /* (선택) 더 촘촘하게 */






  </style>


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4324510515730355" crossorigin="anonymous"></script>


</head>
<body class="theme-pink">
  <div id="app-header"></div>

  <main class="container" style="min-height:60vh">

    
  <!-- ✅ 인페이지 광고 (본문 안, 맨 위) -->
  <div id="ad-inpage" class="ad-slot">
    <!-- AdSense 반응형 디스플레이 유닛 코드 -->
  </div>
  
    <section id="view-dotart">
      <div class="content">
        <div class="filters" role="tablist" aria-label="filters">
          <button class="chip is-active" data-filter="all">All</button>
          <button class="chip" data-filter="converter">Dot Art Converter</button>
          <button class="chip" data-filter="dotart">Dot Art</button>
                  <button class="chip" data-filter="ascii">ASCII Art</button>
        </div>

        <!-- All / Converter에서 보이는 상단 섹션 -->
        <div id="converterSection" class="section">
          <h3>Dot Art Converter</h3>
          <div class="convert-wrap">
            <div class="convert-row">
              <!-- 업로드 -->
              <div class="convert-col">
                <div class="upload">
                  <div class="file-upload">
                    <input id="dotFile" type="file" accept="image/*" aria-label="Upload image" />
                    <div class="upload-hint">
                      <span class="icon">📁</span>
                      <span class="label">Click to select image</span>
                    </div>
                  </div>

                  <div class="preview" id="previewBox">
                    <img id="dotPreview" class="preview-img" alt="preview" hidden />
                    <div class="hint">Pick an image to preview here.</div>
                  </div>

                  <div class="ctrl-box">
                    <div class="ctrls">
                      <label class="ctrl">
                        <span class="label">Accuracy: <span id="accVal">127</span></span>
                        <input id="accRange" type="range" min="1" max="255" step="1" value="127" />
                      </label>
                      <label class="ctrl">
                        <span class="label"><input id="invertChk" type="checkbox" /> Invert background</span>
                      </label>
                    </div>
                  </div>
                </div>
              </div>

              <!-- 결과 -->
              <div class="convert-col">
                <h3 style="margin:0 0 8px">Result</h3>
                <pre id="dotResult" class="result" aria-label="Dot art result">(Upload an image to see dot art here)</pre>
                <div style="display:flex; justify-content:center; margin-top:8px;">
                  <button id="copyResult" class="chip">Copy</button>
                </div>
              </div>
            </div>
          </div>
        </div>
        
        

        <!-- 하단: Dot Art 목록 -->
        <div id="dotSection" class="section">
          <h3>Dot Art</h3>
          <section id="grid" aria-live="polite"></section>
          <div id="empty">No results.</div></div>
          
          


 

        
        <!-- 하단: ASCII Art 목록 -->
        <div id="asciiSection" class="section" style="display:none">
          <h3>ASCII Art</h3>
          <section id="asciiGrid" aria-live="polite"></section>
          <div id="asciiEmpty">No results.</div>
        
     </div>


       </div>
    </section>
  </main>

  <div id="toast" role="status" aria-live="polite">Copied!</div>
  <div id="app-footer"></div>

  <script src="./include-layout.js" defer></script>
  <script src="./dotart-data.js" defer></script>
  <script src="./asciiart-data.js" defer></script>

  <script>
  // ===== 상태 & 엘리먼트 =====
  const $filters = document.querySelector('.filters');
  const $grid = document.getElementById('grid');
  const $empty = document.getElementById('empty');
  const $converter = document.getElementById('converterSection');
  const $dot = document.getElementById('dotSection');
  let FILTER = 'all';
  const $ascii = document.getElementById('asciiSection');
  const $asciiGrid = document.getElementById('asciiGrid');
  const $asciiEmpty = document.getElementById('asciiEmpty');

  // ===== Dot Art 데이터 (문자열 배열/객체 배열 모두 지원) =====
  function getDotItems(){
    const base = (window.DOTART_ITEMS || (typeof DOTART_ITEMS!=='undefined' ? DOTART_ITEMS : []));
    // 문자열이면 {t:...}로 래핑
    return base.map(it => (typeof it === 'string' ? { t: it } : it)).filter(Boolean);
  }

  function getAsciiItems(){
    const base = (window.ASCIIART_ITEMS || (typeof ASCIIART_ITEMS!=='undefined' ? ASCIIART_ITEMS : []));
    return base.map(it => (typeof it === 'string' ? { t: it } : it)).filter(Boolean);
  }

  // ===== 즐겨찾기 (선택) =====
  const FAV_KEY = 'dotart.favs.v1';
  function loadFav(){ try{ return new Set(JSON.parse(localStorage.getItem(FAV_KEY)||'[]')); }catch{ return new Set(); } }
  function saveFav(set){ localStorage.setItem(FAV_KEY, JSON.stringify([...set])); }
  const favs = loadFav();

  // ===== 렌더 =====
  function render(){
    // 섹션 표시/숨김
    $converter.style.display = (FILTER==='all' || FILTER==='converter') ? '' : 'none';
    $dot.style.display       = (FILTER==='all' || FILTER==='dotart') ? '' : 'none';
    $ascii.style.display     = (FILTER==='all' || FILTER==='ascii') ? '' : 'none';

    // Dot Art 목록 렌더
    if ($dot.style.display!=='none'){
      const items = getDotItems();
      $grid.innerHTML = '';
      if (!items.length){ $empty.style.display='block'; }
      else { $empty.style.display='none'; }

      const frag = document.createDocumentFragment();
      for (const it of items){
        const text = it.t || '';
        const card = document.createElement('button');
        card.className = 'dot-card';
        card.type = 'button';
        card.title = 'Click to copy';

        const meta = document.createElement('div');
        meta.className = 'dot-meta';
        const favBtn = document.createElement('button');
        favBtn.className = 'fav-btn';
        favBtn.type = 'button';
        const isFav = favs.has(text);
        favBtn.textContent = isFav ? '★' : '☆';
        favBtn.setAttribute('aria-pressed', isFav);
        favBtn.addEventListener('click', (e)=>{
          e.stopPropagation();
          if (favs.has(text)) favs.delete(text); else favs.add(text);
          favBtn.textContent = favs.has(text) ? '★' : '☆';
          favBtn.setAttribute('aria-pressed', favs.has(text));
          saveFav(favs);
        });
        meta.appendChild(favBtn);

        const pre = document.createElement('pre');
        pre.textContent = text;

        card.append(meta, pre);
        card.addEventListener('click', async ()=>{ await copyText(text); toast('Copied!'); });
        frag.appendChild(card);
      }
      $grid.appendChild(frag);
    }
    
    // ASCII Art 목록 렌더
    if ($ascii.style.display!=='none'){
      const items = getAsciiItems();
      $asciiGrid.innerHTML = '';
      if (!items.length){ $asciiEmpty.style.display='block'; }
      else { $asciiEmpty.style.display='none'; }

      const frag = document.createDocumentFragment();
      for (const it of items){
        const text = it.t || '';
        const card = document.createElement('button');
        card.className = 'dot-card';
        card.type = 'button';
        card.title = 'Click to copy';

        const meta = document.createElement('div');
        meta.className = 'dot-meta';
        const favBtn = document.createElement('button');
        favBtn.className = 'fav-btn';
        favBtn.type = 'button';
        const isFav = favs.has(text);
        favBtn.textContent = isFav ? '★' : '☆';
        favBtn.setAttribute('aria-pressed', isFav);
        favBtn.addEventListener('click', (e)=>{
          e.stopPropagation();
          if (favs.has(text)) favs.delete(text); else favs.add(text);
          favBtn.textContent = favs.has(text) ? '★' : '☆';
          favBtn.setAttribute('aria-pressed', favs.has(text));
          saveFav(favs);
        });
        meta.appendChild(favBtn);

        const pre = document.createElement('pre');
        pre.className = 'ascii-pre';
        pre.textContent = normalizeAscii(text);

        card.append(meta, pre);
        card.addEventListener('click', async ()=>{ await copyText(text); toast('Copied!'); });

        frag.appendChild(card);
      }
      $asciiGrid.appendChild(frag);
    }
}

function normalizeAscii(s){
  return s
    .replace(/\r\n?/g, '\n')                       // 줄바꿈 통일
    .replace(/[\u2000-\u200A\u202F\u205F\u00A0]/g, ' ') // 얇은/특수 공백 → 일반 공백
    .replace(/\t/g, '  ');                         // 탭은 2칸으로 고정
}


  // ===== 필터 클릭 =====
  $filters.addEventListener('click', (e)=>{
    const btn = e.target.closest('[data-filter]'); if(!btn) return;
    document.querySelectorAll('.filters .chip').forEach(b=>b.classList.remove('is-active'));
    btn.classList.add('is-active');
    FILTER = (btn.dataset.filter||'all').toLowerCase();
    render();
  });

  // ===== 복사/토스트 =====
  async function copyText(s){
    try{
      await navigator.clipboard.writeText(s);
    }catch{
      const ta=document.createElement('textarea'); ta.value=s;
      document.body.appendChild(ta); ta.select(); document.execCommand('copy'); ta.remove();
    }
  }
  function toast(msg){
    const t = document.getElementById('toast');
    t.textContent = msg;
    t.classList.add('show');
    clearTimeout(toast._t);
    toast._t = setTimeout(()=> t.classList.remove('show'), 900);
  }

// ===== Converter 로직 (도트아트 변환기) =====
(function(){
  const imgInput   = document.getElementById('dotFile');
  const imgPrev    = document.getElementById('dotPreview');
  const previewBox = document.getElementById('previewBox');
  const outPre     = document.getElementById('dotResult');
  const rangeAcc   = document.getElementById('accRange');
  const accLabel   = document.getElementById('accVal');
  const invertCb   = document.getElementById('invertChk');
  const copyBtn    = document.getElementById('copyResult');

  const cvs = document.createElement('canvas');
  const ctx = cvs.getContext('2d', { willReadFrequently:true });

  function approxCharWidthPx(){
    const test=document.createElement('span');
    test.style.fontFamily=getComputedStyle(outPre).fontFamily;
    test.style.fontSize  =getComputedStyle(outPre).fontSize;
    test.style.visibility='hidden';
    test.textContent='M';
    document.body.appendChild(test);
    const w=test.getBoundingClientRect().width||8;
    document.body.removeChild(test);
    return w;
  }
  
  function autoTargetCols(){
    const pad=16*2;
    const boxW=outPre.clientWidth||600;
    const cw=approxCharWidthPx();
    const cols=Math.max(20, Math.floor((boxW-pad)/cw));
    return Math.min(cols, 30);
  }
  
  function loadImage(file){
    return new Promise((resolve,reject)=>{
      const fr=new FileReader();
      fr.onload=()=>{ 
        const im=new Image(); 
        im.onload=()=>resolve(im); 
        im.onerror=reject; 
        im.src=fr.result; 
      };
      fr.onerror=reject; 
      fr.readAsDataURL(file); 
    });
  }
  
  function luminance(r,g,b){ 
    return 0.2126*r + 0.7152*g + 0.0722*b;
}

  // 이미지 → 점자(브라유) 문자열(U+2800 기반, 2x4 셀)
  function imageToBraille(img, opts){
    const { cols=100, threshold=127, invert=false } = opts;
    const cellW=2, cellH=4;
    const targetW=cols*cellW;
    const scale=targetW/img.width;
    const targetH=Math.max(1, Math.round(img.height*scale));

    cvs.width=targetW; cvs.height=targetH;
    ctx.clearRect(0,0,cvs.width,cvs.height);
    ctx.imageSmoothingEnabled=false;
    ctx.drawImage(img,0,0,cvs.width,cvs.height);

    const id=ctx.getImageData(0,0,cvs.width,cvs.height);
    const data=id.data;

    const rows = Math.floor(targetH/cellH);
    const colsBraille = Math.floor(targetW/cellW);
    let out='';

    for(let y=0; y<rows; y++){
      for(let x=0; x<colsBraille; x++){
        let mask=0;
        
        // 브라유 점자 비트 위치 (2x4 셀):
        // 1 4
        // 2 5  
        // 3 6
        // 7 8
        
        // 각 점의 on/off를 밝기 기준으로 결정
        const x0 = x*cellW, x1 = x0+1;
        const y0 = y*cellH;
        
        function isOn(px, py){
          if(px >= targetW || py >= targetH) return false;
          const idx = (py * targetW + px) * 4;
          const lum = luminance(data[idx], data[idx+1], data[idx+2]);
          const on = (lum <= threshold);
          return invert ? !on : on;
        }
        
        // 점1 (x0, y0)
        if(isOn(x0, y0+0)) mask |= 0x01;
        // 점2 (x0, y0+1)  
        if(isOn(x0, y0+1)) mask |= 0x02;
        // 점3 (x0, y0+2)
        if(isOn(x0, y0+2)) mask |= 0x04;
        // 점4 (x1, y0+0)
        if(isOn(x1, y0+0)) mask |= 0x08;
        // 점5 (x1, y0+1)
        if(isOn(x1, y0+1)) mask |= 0x10;
        // 점6 (x1, y0+2)
        if(isOn(x1, y0+2)) mask |= 0x20;
        // 점7 (x0, y0+3)
        if(isOn(x0, y0+3)) mask |= 0x40;
        // 점8 (x1, y0+3)
        if(isOn(x1, y0+3)) mask |= 0x80;
        
        out += String.fromCodePoint(0x2800 + mask);
      }
      out += '\n';
    }
    return out;
  }

  async function handleFile(){
    const f = imgInput.files && imgInput.files[0];
    if(!f){ 
      imgPrev.hidden=true; 
      previewBox.classList.remove('has-image'); 
      outPre.textContent='(Upload an image to see dot art here)'; 
      return; 
    }
    const img = await loadImage(f);
    imgPrev.src = img.src; 
    imgPrev.hidden=false; 
    previewBox.classList.add('has-image');
    renderBraille(img);
  }
  
  function renderBraille(img){
    const cols = autoTargetCols();
    const threshold = Number(rangeAcc.value)||127;
    const invert = !!invertCb.checked;
    accLabel.textContent = threshold;
    const txt = imageToBraille(img, { cols, threshold, invert });
    outPre.textContent = txt;
  }

  // 이벤트 리스너 연결
  imgInput?.addEventListener('change', handleFile);
  rangeAcc?.addEventListener('input', ()=>{
    if(imgPrev && !imgPrev.hidden){ 
      const im=new Image(); 
      im.onload=()=>renderBraille(im); 
      im.src=imgPrev.src; 
    } 
    accLabel.textContent=rangeAcc.value; 
  });
  invertCb?.addEventListener('change', ()=>{
    if(imgPrev && !imgPrev.hidden){ 
      const im=new Image(); 
      im.onload=()=>renderBraille(im); 
      im.src=imgPrev.src; 
    } 
  });

  copyBtn?.addEventListener('click', async ()=>{
    await copyText(outPre.textContent||''); 
    toast('Copied!'); 
  });
})();

  // 초기 로드: All로 시작
  document.addEventListener('DOMContentLoaded', ()=>{
    FILTER='all';
    render();
  });
  </script>
</body>
</html>
